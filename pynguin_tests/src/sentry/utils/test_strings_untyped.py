# Test cases automatically generated by Pynguin (https://www.pynguin.eu).
# Please check them before you use them.
import pytest
import strings_untyped as module_0
import enum as module_1
import base64 as module_2


def test_case_0():
    none_type_0 = None
    var_0 = module_0.truncatechars(none_type_0, none_type_0)
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_1():
    bool_0 = True
    module_0.truncatechars(bool_0, bool_0)


def test_case_2():
    bool_0 = False
    var_0 = module_0.strip(bool_0)
    assert var_0 == ""
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_3():
    none_type_0 = None
    var_0 = module_0.strip(none_type_0)
    assert var_0 == ""
    assert len(module_0.valid_dot_atom_characters) == 82
    module_0.soft_break(var_0, var_0, var_0)


def test_case_4():
    none_type_0 = None
    var_0 = module_0.is_valid_dot_atom(none_type_0)
    assert var_0 is False
    assert len(module_0.valid_dot_atom_characters) == 82


def test_case_5():
    bool_0 = True
    var_0 = module_0.codec_lookup(bool_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "codecs.CodecInfo"
    assert len(var_0) == 4
    assert len(module_0.valid_dot_atom_characters) == 82


def test_case_6():
    none_type_0 = None
    var_0 = module_0.codec_lookup(none_type_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "codecs.CodecInfo"
    assert len(var_0) == 4
    assert len(module_0.valid_dot_atom_characters) == 82


def test_case_7():
    str_0 = "$L)"
    var_0 = module_0.oxfordize_list(str_0)
    assert var_0 == "$, L, and )"
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_8():
    none_type_0 = None
    module_0.unescape_string(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_9():
    bool_0 = True
    module_0.strip_lone_surrogates(bool_0)


@pytest.mark.xfail(strict=True)
def test_case_10():
    none_type_0 = None
    module_0.compress(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_11():
    bytes_0 = b"~Yc\x93YF\xc7bzr\x08\xfb&\xce\xe6\xf06\xce=\xc5"
    module_0.decompress(bytes_0)


@pytest.mark.xfail(strict=True)
def test_case_12():
    none_type_0 = None
    module_0.soft_hyphenate(none_type_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_13():
    none_type_0 = None
    module_0.soft_break(none_type_0, none_type_0, none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_14():
    none_type_0 = None
    module_0.count_sprintf_parameters(none_type_0)


@pytest.mark.xfail(strict=True)
def test_case_15():
    none_type_0 = None
    module_0.to_single_line_str(none_type_0)


def test_case_16():
    str_0 = "L}"
    var_0 = module_0.is_valid_dot_atom(str_0)
    assert var_0 is True
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_17():
    bool_0 = False
    var_0 = module_0.to_unicode(bool_0)
    assert len(module_0.valid_dot_atom_characters) == 82
    var_1 = module_0.codec_lookup(var_0)
    assert f"{type(var_1).__module__}.{type(var_1).__qualname__}" == "codecs.CodecInfo"
    assert len(var_1) == 4
    var_2 = module_0.truncatechars(var_0, bool_0)
    assert var_2 == "..."
    var_3 = module_0.truncatechars(bool_0, var_0)
    assert var_3 is False
    var_4 = module_0.codec_lookup(var_3)
    var_2.items()


def test_case_18():
    bool_0 = True
    var_0 = module_0.strip(bool_0)
    assert var_0 == "True"
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_19():
    complex_0 = 1446.91 + 3381.8413j
    module_0.truncatechars(complex_0, complex_0)


@pytest.mark.xfail(strict=True)
def test_case_20():
    bool_0 = False
    var_0 = module_1._EnumDict()
    var_1 = module_0.truncatechars(var_0, bool_0, bool_0)
    assert f"{type(var_1).__module__}.{type(var_1).__qualname__}" == "enum._EnumDict"
    assert len(var_1) == 0
    assert len(module_0.valid_dot_atom_characters) == 82
    module_0.strip_lone_surrogates(bool_0)


def test_case_21():
    str_0 = "L}"
    var_0 = module_0.truncatechars(str_0, str_0, str_0)
    assert var_0 == "L}"
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_22():
    bool_0 = True
    var_0 = module_0.to_unicode(bool_0)
    assert var_0 == "True"
    assert len(module_0.valid_dot_atom_characters) == 82
    var_1 = module_0.codec_lookup(var_0)
    assert f"{type(var_1).__module__}.{type(var_1).__qualname__}" == "codecs.CodecInfo"
    assert len(var_1) == 4
    var_2 = module_0.is_valid_dot_atom(var_0)
    assert var_2 is True
    var_3 = module_0.soft_hyphenate(var_0, var_2)
    assert var_3 == "T\xadr\xadu\xade"
    var_4 = module_0.truncatechars(bool_0, var_0)
    assert var_4 is True
    module_0.strip_lone_surrogates(var_4)


@pytest.mark.xfail(strict=True)
def test_case_23():
    bool_0 = True
    var_0 = module_0.is_valid_dot_atom(bool_0)
    assert var_0 is False
    assert len(module_0.valid_dot_atom_characters) == 82
    var_1 = module_0.to_unicode(bool_0)
    var_2 = module_0.codec_lookup(var_1)
    assert f"{type(var_2).__module__}.{type(var_2).__qualname__}" == "codecs.CodecInfo"
    assert len(var_2) == 4
    var_3 = module_0.is_valid_dot_atom(var_1)
    assert var_3 is True
    var_4 = module_0.truncatechars(var_0, var_1)
    assert var_4 is False
    var_5 = module_0.strip(var_4)
    assert var_5 == ""
    var_6 = module_0.soft_break(var_1, var_5)
    assert var_6 == "True"
    var_7 = module_0.codec_lookup(var_6)
    var_8 = module_0.is_valid_dot_atom(var_0)
    var_9 = var_2.__iter__()
    module_2.b32hexencode(var_0)


@pytest.mark.xfail(strict=True)
def test_case_24():
    bool_0 = True
    var_0 = module_0.is_valid_dot_atom(bool_0)
    assert var_0 is False
    assert len(module_0.valid_dot_atom_characters) == 82
    var_1 = module_0.to_unicode(bool_0)
    var_2 = module_0.codec_lookup(var_1)
    assert f"{type(var_2).__module__}.{type(var_2).__qualname__}" == "codecs.CodecInfo"
    assert len(var_2) == 4
    var_3 = module_0.is_valid_dot_atom(var_1)
    assert var_3 is True
    var_4 = module_0.truncatechars(var_1, var_3)
    assert var_4 == "..."
    var_5 = module_0.truncatechars(var_0, var_1)
    assert var_5 is False
    var_6 = module_0.strip(var_5)
    assert var_6 == ""
    var_7 = module_0.codec_lookup(var_2)
    var_8 = module_0.strip(var_2)
    assert var_8 == "<codecs.CodecInfo object for encoding utf-8 at 0x7f2a907b9900>"
    var_9 = module_0.codec_lookup(var_2)
    var_10 = module_0.is_valid_dot_atom(var_4)
    assert var_10 is False
    var_11 = module_0.to_single_line_str(var_8)
    assert var_11 == "<codecs.CodecInfo object for encoding utf-8 at 0x7f2a907b9900>"
    var_1.copy()


def test_case_25():
    str_0 = ""
    var_0 = module_0.oxfordize_list(str_0)
    assert var_0 == ""
    assert len(module_0.valid_dot_atom_characters) == 82


@pytest.mark.xfail(strict=True)
def test_case_26():
    none_type_0 = None
    var_0 = module_0.codec_lookup(none_type_0)
    assert f"{type(var_0).__module__}.{type(var_0).__qualname__}" == "codecs.CodecInfo"
    assert len(var_0) == 4
    assert len(module_0.valid_dot_atom_characters) == 82
    var_1 = module_0.is_valid_dot_atom(var_0)
    assert var_1 is False
    var_2 = module_0.to_unicode(var_0)
    var_3 = module_0.is_valid_dot_atom(var_2)
    assert var_3 is False
    var_4 = module_0.truncatechars(var_2, var_3)
    assert var_4 == "..."
    var_5 = module_0.truncatechars(var_1, var_2)
    assert var_5 is False
    var_6 = module_0.strip(var_5)
    assert var_6 == ""
    var_7 = module_0.oxfordize_list(var_4)
    assert var_7 == "., ., and ."
    var_8 = module_0.soft_break(var_2, var_6)
    assert (
        var_8
        == "<\u200bcodecs.\u200bCodecInfo object for encoding utf-8 at 0x7f2a907b9900>"
    )
    var_9 = module_0.to_single_line_str(var_2)
    assert var_9 == "<codecs.CodecInfo object for encoding utf-8 at 0x7f2a907b9900>"
    var_10 = module_0.strip(var_8)
    assert (
        var_10
        == "<\u200bcodecs.\u200bCodecInfo object for encoding utf-8 at 0x7f2a907b9900>"
    )
    var_11 = module_0.truncatechars(var_4, var_5)
    assert var_11 == "..."
    module_0.codec_lookup(var_3, var_5)


def test_case_27():
    str_0 = "L}"
    var_0 = module_0.oxfordize_list(str_0)
    assert var_0 == "L and }"
    assert len(module_0.valid_dot_atom_characters) == 82


def test_case_28():
    bytes_0 = b"\x7f\x7f^\xa1Z\xa5\xeeO\xce\xf2\xae"
    var_0 = module_0.to_unicode(bytes_0)
    assert var_0 == "(Error decoding value)"
    assert len(module_0.valid_dot_atom_characters) == 82
    var_1 = module_0.is_valid_dot_atom(var_0)
    assert var_1 is False


def test_case_29():
    str_0 = "L"
    var_0 = module_0.oxfordize_list(str_0)
    assert var_0 == "L"
    assert len(module_0.valid_dot_atom_characters) == 82
